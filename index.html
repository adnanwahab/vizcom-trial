<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Garment Mockup POC</title>
  <!-- Replace old script tags with ES module imports -->
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      display: flex;
      height: 100vh;
    }
    #canvas-container {
      position: relative;
      width: 70%;
      height: 100%;
      background: #333;
    }
    #ui-container {
      width: 30%;
      display: flex;
      flex-direction: column;
      padding: 10px;
      box-sizing: border-box;
      background: #f5f5f5;
    }
    #sourceImageCanvas {
      width: 100%;
      max-height: 300px;
      border: 1px solid #ccc;
      cursor: crosshair;
    }
    #applyButton {
      margin: 10px 0;
      padding: 8px 16px;
      font-size: 1em;
      cursor: pointer;
    }
    #sourceImageCanvasWrapper {
      position: relative;
      width: 100%;
    }
    #selectionBox {
      position: absolute;
      border: 2px dashed #ff0000;
      pointer-events: none;
      display: none; /* hidden by default until user drags */
    }
    .hint {
      font-size: 0.9em;
      color: #666;
    }
    .texture-controls {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .control-group {
      margin: 10px 0;
    }
    .control-group label {
      display: block;
      margin-bottom: 5px;
    }
    .control-group input {
      width: 100%;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    //import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    //import { TransformControls } from 'three/addons/controls/TransformControls.js';
    
    // Make THREE available globally for the rest of your code
    // window.THREE = THREE;
    // window.OrbitControls = OrbitControls;
    // window.TransformControls = TransformControls;
  </script>

</head>
<body>
  <!-- 3D Scene -->
  <div id="canvas-container"></div>

  <!-- UI Sidebar -->
  <div id="ui-container">
    <h3>Garment Selection Region </h3>
    <div id="sourceImageCanvasWrapper">
      <canvas id="sourceImageCanvas" width="400" height="300"></canvas>
      <div id="selectionBox"></div>
    </div>
    <button id="applyButton">Apply to Model</button>
    <button id="toggleNormalMap">Toggle Normal Map</button>
    <button id="toggleMaterial">Toggle Phong Material</button>
    <div class="texture-controls">
      <h4>Texture Controls</h4>
      <div class="control-group">
        <label>Repeat X: <span id="repeatXValue">1</span></label>
        <input type="range" id="repeatX" min="0.1" max="5" step="0.1" value="1">
      </div>
      <div class="control-group">
        <label>Repeat Y: <span id="repeatYValue">1</span></label>
        <input type="range" id="repeatY" min="0.1" max="5" step="0.1" value="1">
      </div>
      <div class="control-group">
        <label>Offset X: <span id="offsetXValue">0</span></label>
        <input type="range" id="offsetX" min="-1" max="1" step="0.1" value="0">
      </div>
      <div class="control-group">
        <label>Offset Y: <span id="offsetYValue">0</span></label>
        <input type="range" id="offsetY" min="-1" max="1" step="0.1" value="0">
      </div>
      <div class="control-group">
        <label>Rotation: <span id="rotationValue">0°</span></label>
        <input type="range" id="rotation" min="0" max="360" step="1" value="0">
      </div>

      <!-- New Perspective Wrapping Controls -->
      <div class="control-group">
        <label>Perspective Wrapping:</label>
        <input type="checkbox" id="perspectiveWrapping">
      </div>
      <div class="control-group">
        <label>Wrap S:</label>
        <select id="wrapS">
          <option value="RepeatWrapping">Repeat</option>
          <option value="ClampToEdgeWrapping">Clamp</option>
          <option value="MirroredRepeatWrapping">Mirrored Repeat</option>
        </select>
      </div>
      <div class="control-group">
        <label>Wrap T:</label>
        <select id="wrapT">
          <option value="RepeatWrapping">Repeat</option>
          <option value="ClampToEdgeWrapping">Clamp</option>
          <option value="MirroredRepeatWrapping">Mirrored Repeat</option>
        </select>
      </div>
      <div class="control-group">
        <label>Perspective Threshold (dot product): <span id="perspectiveThresholdValue">0.5</span></label>
        <input type="range" id="perspectiveThreshold" min="0" max="1" step="0.01" value="0.5">
      </div>
    </div>
    <p class="hint">Drag & drop an image onto the 3D view to replace this source image.</p>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';

    // Global variables
    let scene, camera, renderer, orbitControls, transformControls;
    let shirtMesh, shirtTexture;
    let sourceImageCanvas, sourceCtx;
    let selectionBox;
    let isSelecting = false;
    let startX, startY;
    let selectionWidth, selectionHeight;
    let sourceImage; // Store the last dropped/loaded image
    let showNormalMap = false;
    let normalMapTexture;
    let isPhongMaterial = false;

    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', () => {
      init();
      animate();
    });

    /*************************************
     * Initialize Scene
     *************************************/
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xaaaaaa);

      // Camera
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth * 0.7 / window.innerHeight, // note: 70% width
        0.1,
        1000
      );
      camera.position.set(0, 1.5, 3);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      const container = document.getElementById("canvas-container");
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // Orbit Controls
      orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.enableDamping = true;

      // Transform Controls
      // transformControls = new THREE.TransformControls(camera, renderer.domElement);
      //  transformControls.addEventListener('change', render);
      // scene.add(transformControls);

      // Add a basic directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(3, 10, 10);
      scene.add(dirLight);
      const ambLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambLight);

      // Basic ground plane
      const planeGeometry = new THREE.PlaneGeometry(200, 200);
      const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const ground = new THREE.Mesh(planeGeometry, planeMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1;
      scene.add(ground);

      // Modify the vase geometry to have better UV mapping
      const points = [];
      for (let i = 0; i < 10; i++) {
        const t = i / 9;
        const radius = 0.3 + Math.sin(t * Math.PI) * 0.2;
        points.push(new THREE.Vector2(radius, t * 1.5));
      }
      const vaseGeometry = new THREE.LatheGeometry(points, 32);
      
      // Improve UV mapping for the vase
      const uvAttribute = vaseGeometry.attributes.uv;
      for (let i = 0; i < uvAttribute.count; i++) {
        const u = uvAttribute.getX(i);
        const v = uvAttribute.getY(i);
        // Adjust UV coordinates to better wrap around the vase
        uvAttribute.setXY(i, u * 1, v);
      }

      shirtTexture = new THREE.TextureLoader().load('https://picsum.photos/id/237/200/300');
      normalMapTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg');
      
      const shirtMaterial = new THREE.MeshPhysicalMaterial({ 
          color: 0x049ef4,  // Bright blue color matching the reference
          metalness: 0.3,
          roughness: 0.2,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          envMapIntensity: 1.0,
          transparent: false,
          opacity: 1,
          side: THREE.FrontSide
      });
      
      shirtMesh = new THREE.Mesh(vaseGeometry, shirtMaterial);
      shirtMesh.position.y = 0;  // Adjusted position to sit on the ground
      scene.add(shirtMesh);

      // Make the shirt transformable
      // transformControls.attach(shirtMesh);
      // scene.add(transformControls);

      // Setup drag & drop for the 3D canvas container
      setupDragAndDrop(container);

      // UI Setup: Source image canvas
      sourceImageCanvas = document.getElementById("sourceImageCanvas");
      sourceCtx = sourceImageCanvas.getContext("2d");

      selectionBox = document.getElementById("selectionBox");
      sourceImage = new Image();
      sourceImage.crossOrigin = "anonymous";
      sourceImage.onload = function() {
        drawImageToSourceCanvas(sourceImage);
      };
      // Load a default image for demonstration
      sourceImage.src = "https://picsum.photos/400/300";

      // Setup manual selection events
      sourceImageCanvas.addEventListener("mousedown", startSelection);
      sourceImageCanvas.addEventListener("mousemove", updateSelection);
      sourceImageCanvas.addEventListener("mouseup", endSelection);

      // Button: Apply selected area to the model
      document.getElementById("applyButton").addEventListener("click", applyToModel);

      // Add normal map toggle button handler
      document.getElementById("toggleNormalMap").addEventListener("click", () => {
        showNormalMap = !showNormalMap;
        if (showNormalMap) {
          shirtMesh.material.normalMap = normalMapTexture;
        } else {
          shirtMesh.material.normalMap = null;
        }
        shirtMesh.material.needsUpdate = true;
      });

      // Add material toggle button handler
      document.getElementById("toggleMaterial").addEventListener("click", () => {
        isPhongMaterial = !isPhongMaterial;
        const currentMap = shirtMesh.material.map;
        const currentNormalMap = shirtMesh.material.normalMap;
        
        if (isPhongMaterial) {
          shirtMesh.material = new THREE.MeshPhongMaterial({
            map: currentMap,
            normalMap: currentNormalMap,
            normalScale: new THREE.Vector2(1, 1),
            shininess: 30
          });
        } else {
          shirtMesh.material = new THREE.MeshStandardMaterial({
            map: currentMap,
            normalMap: currentNormalMap,
            normalScale: new THREE.Vector2(1, 1)
          });
        }
        shirtMesh.material.needsUpdate = true;
      });

      // Setup texture controls
      setupTextureControls();

      window.addEventListener("resize", onWindowResize);
    }

    /*************************************
     * Event Handlers
     *************************************/
    function onWindowResize() {
      const container = document.getElementById("canvas-container");
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
      render();
    }

    function startSelection(e) {
      isSelecting = true;
      const rect = sourceImageCanvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      selectionBox.style.left = startX + 'px';
      selectionBox.style.top = startY + 'px';
      selectionBox.style.width = '0px';
      selectionBox.style.height = '0px';
      selectionBox.style.display = 'block';
    }

    function updateSelection(e) {
      if (!isSelecting) return;
      const rect = sourceImageCanvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      selectionWidth = currentX - startX;
      selectionHeight = currentY - startY;

      selectionBox.style.width = Math.abs(selectionWidth) + 'px';
      selectionBox.style.height = Math.abs(selectionHeight) + 'px';
      selectionBox.style.left = Math.min(startX, currentX) + 'px';
      selectionBox.style.top = Math.min(startY, currentY) + 'px';
    }

    function endSelection(e) {
      isSelecting = false;
    }

    function applyToModel() {
      if (!selectionWidth || !selectionHeight) return;
      
      const cropCanvas = document.createElement('canvas');
      cropCanvas.width = Math.abs(selectionWidth);
      cropCanvas.height = Math.abs(selectionHeight);
      const cropCtx = cropCanvas.getContext('2d', { willReadFrequently: true });

      const sx = parseInt(selectionBox.style.left, 10);
      const sy = parseInt(selectionBox.style.top, 10);
      const sw = parseInt(selectionBox.style.width, 10);
      const sh = parseInt(selectionBox.style.height, 10);

      cropCtx.drawImage(
        sourceImageCanvas,
        sx, sy, sw, sh,
        0, 0, sw, sh
      );

      const croppedTexture = new THREE.CanvasTexture(cropCanvas);
      croppedTexture.wrapS = THREE.RepeatWrapping;
      croppedTexture.wrapT = THREE.RepeatWrapping;
      
      shirtMesh.material.map = croppedTexture;
      shirtMesh.material.normalMap = showNormalMap ? normalMapTexture : null;
      
      // Apply current texture transform settings
      updateTextureTransform();
      
      shirtMesh.material.needsUpdate = true;

      selectionBox.style.display = 'none';
      selectionWidth = 0;
      selectionHeight = 0;
    }

    /*************************************
     * Utility: Draw image onto source canvas
     *************************************/
    function drawImageToSourceCanvas(img) {
      // Fill canvas with the image
      sourceCtx.clearRect(0, 0, sourceImageCanvas.width, sourceImageCanvas.height);
      // Scale image to fit or fill the canvas:
      sourceCtx.drawImage(img, 0, 0, sourceImageCanvas.width, sourceImageCanvas.height);
    }

    /*************************************
     * Drag & Drop Setup
     *************************************/
    function setupDragAndDrop(dropTarget) {
      dropTarget.addEventListener('dragover', (e) => {
        e.preventDefault();
      });
      dropTarget.addEventListener('drop', (e) => {
        e.preventDefault();
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          const file = e.dataTransfer.files[0];
          const reader = new FileReader();
          reader.onload = (ev) => {
            sourceImage.src = ev.target.result;
          };
          reader.readAsDataURL(file);
        }
      });
    }

    /*************************************
     * Texture Controls
     *************************************/
    function setupTextureControls() {
      const controls = ['repeatX', 'repeatY', 'offsetX', 'offsetY', 'rotation'];
      
      controls.forEach(control => {
        const slider = document.getElementById(control);
        const valueDisplay = document.getElementById(`${control}Value`);
        
        slider.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          valueDisplay.textContent = control.includes('rotation') ? `${value}°` : value;
          updateTextureTransform();
        });
      });

      // Update perspective threshold display value live
      const perspectiveThresholdSlider = document.getElementById("perspectiveThreshold");
      perspectiveThresholdSlider.addEventListener("input", (e) => {
        document.getElementById("perspectiveThresholdValue").textContent = e.target.value;
      });
    }

    function updateTextureTransform() {
      if (!shirtMesh.material.map) return;

      const repeatX = parseFloat(document.getElementById('repeatX').value);
      const repeatY = parseFloat(document.getElementById('repeatY').value);
      const offsetX = parseFloat(document.getElementById('offsetX').value);
      const offsetY = parseFloat(document.getElementById('offsetY').value);
      const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;

      shirtMesh.material.map.repeat.set(repeatX, repeatY);
      shirtMesh.material.map.offset.set(offsetX, offsetY);
      shirtMesh.material.map.rotation = rotation;
      shirtMesh.material.map.center.set(0.5, 0.5); // Set rotation center to middle of texture
      shirtMesh.material.map.needsUpdate = true;
    }

    /*************************************
     * Perspective Wrapping: Additional Wrapping Controls
     *************************************/
    function updatePerspectiveWrapping() {
      // Only update if the "Perspective Wrapping" checkbox is enabled.
      const perspectiveEnabled = document.getElementById("perspectiveWrapping").checked;
      if (!perspectiveEnabled) return;

      const threshold = parseFloat(document.getElementById("perspectiveThreshold").value);
      const wrapSValue = document.getElementById("wrapS").value;
      const wrapTValue = document.getElementById("wrapT").value;

      // Get camera's current view direction.
      let camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);

      // Assume the model's front is along the +Z axis.
      const modelForward = new THREE.Vector3(0, 0, 1);
      const dot = camDir.dot(modelForward);

      // If the camera is within the threshold (i.e. looking at the front of the model),
      // apply the selected wrapping modes.
      if (dot > threshold) {
        if (shirtMesh.material.map) {
          shirtMesh.material.map.wrapS = THREE[wrapSValue];
          shirtMesh.material.map.wrapT = THREE[wrapTValue];
          shirtMesh.material.map.needsUpdate = true;
        }
      } else {
        // Otherwise, you can revert to your default wrapping mode,
        // for example, to THREE.RepeatWrapping.
        if (shirtMesh.material.map) {
          shirtMesh.material.map.wrapS = THREE.RepeatWrapping;
          shirtMesh.material.map.wrapT = THREE.RepeatWrapping;
          shirtMesh.material.map.needsUpdate = true;
        }
      }
    }

    /*************************************
     * Animation & Render
     *************************************/
    function animate() {
      requestAnimationFrame(animate);
      //orbitControls.update();
      updatePerspectiveWrapping(); // Updates our additional wrapping only when active
      render();
    }

    function render() {
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
